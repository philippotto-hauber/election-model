---
title: "Prepare poll data for model estimation"
format: 
    html:
        page-layout: full
        embed-resources: true
        toc: true
---

This notebook **loads and prepares the scenarios of polling data in the 2024 election cycle**. The transformed data are converted to lists and exported as e.g. `data_scenarioaA.Rda`

## Load libraries and functions

```{r}
#| output: false
library(ggplot2)
library(dplyr)
names_functions = list.files(here::here("functions"))
for (f in names_functions)
    source(here::here("functions", f))
rm(f, names_functions)
```

## Load and wrangle polling data for 2024

```{r}
rawdat <- read.csv(here::here("data", "dataland_polls_2024_scenarios.csv"), stringsAsFactors = FALSE)
keep_cols <- c("scenario", "date_published", "date_conducted",
                "pollster", "geography", "sponsor",
                "sample_size", "cc_poll_share",
                "dgm_poll_share", "pdal_poll_share",
                "ssp_poll_share")
dat <- rawdat[, keep_cols]
```

Add column indicating the *type of poll*: national, regional or state

```{r}
states_regions <- load_dataland_states_regions()
dat$type_of_poll <- determine_type_of_poll(dat$geography, states_regions)
```

Rescale vote shares to account for undecided voters -> party shares need to sum to 1!

```{r}
dat %>% 
    mutate(sum_shares_parties = cc_poll_share +
                                    dgm_poll_share +
                                        pdal_poll_share +
                                            ssp_poll_share,
           cc_poll_share      = cc_poll_share / sum_shares_parties,
           dgm_poll_share     = dgm_poll_share / sum_shares_parties,
           pdal_poll_share    = pdal_poll_share / sum_shares_parties,
           ssp_poll_share     = ssp_poll_share / sum_shares_parties) %>%
    select(-sum_shares_parties) -> dat
```

Check that shares (approximately) sum to 1:

```{r}
#| echo: false
hist(dat$cc_poll_share + 
         dat$dgm_poll_share + 
            dat$pdal_poll_share + 
                dat$ssp_poll_share - 1, 
                xlab = "", 
                main = "Sum of vote shares minus 1")
```

Simplify names of party vote shares

```{r}
dat <- rename(dat, 
    cc_share      = cc_poll_share, 
    dgm_share     = dgm_poll_share,
    pdal_share    = pdal_poll_share,
    ssp_share     = ssp_poll_share)
```

Convert date column to POSIXct

```{r}
dat %>% 
    mutate(date = as.POSIXct(date_published)) %>%
    select(-date_published) -> dat
```

Load the election day according to the calendar and determine the start of the campaign (=earliest poll recored!)
```{r}
start_campaign <- min(dat$date)
end_campaign <- load_election_day(year = 2024)
dates_campaign <- seq(start_campaign, end_campaign, by = "1 day")
```

## Plot available polls in different scenarios

This can be useful information when choosing how tight the prior on the election day voting intentions should be!

```{r}
#| echo: false
# add column with the month of the poll and store in new data frame
dat %>%
    mutate(month = format(date, "%B")) -> df_plot
```

```{r}
#| echo: false
ggplot(df_plot, aes(x = date, fill = type_of_poll)) +
    geom_bar() +
    ggsci::scale_fill_jco() +
    facet_wrap(~scenario) + 
    labs(title = "Availability of polls over time", subtitle = "By type of poll")

ggsave(file = here::here("plots", "available_polls_over_time.png"))
```

```{r}
#| echo: false
ggplot(filter(df_plot), 
        aes(x = geography, fill = month)) +
    geom_bar() + 
    ggsci::scale_fill_jco() +
    facet_wrap(~scenario) + 
    labs(title = "Availability of polls by geography") +
    theme(axis.text.x = element_text(angle = 90)) +
    coord_flip()

 ggsave(file = here::here("plots", "available_polls_by_geography.png"))   
```

```{r}
#| echo: false
ggplot(filter(df_plot), 
        aes(x = geography, fill = sponsor)) +
    geom_bar() + 
    ggsci::scale_fill_jco() +
    facet_wrap(~scenario) + 
    labs(title = "Availability of polls by sponser") +
    theme(axis.text.x = element_text(angle = 90)) +
    coord_flip()

 ggsave(file = here::here("plots", "available_polls_by_sponsor.png"))   
```

```{r}
#| echo: false
rm(df_plot)
```

## Convert polls to a Stan-friendly list

Load list of pollsters 
```{r}
pollsters <- load_pollsters()
```

Loop over scenarios
```{r}
scenarios <- unique(dat$scenario)    
polls <- list() # initialize empty list
for (scenario in scenarios){
    
    polls[[scenario]] <- list()
    
    # state polls----

    dat %>%
    filter(scenario == .env$scenario,
           type_of_poll == "state") %>%
    select(-c("scenario", "type_of_poll")) %>%
    arrange(date) -> df_polls_state

    # convert vote shares to votes
    df_polls_state %>%
        mutate( cc_n      = round(cc_share * sample_size, digits = 0),
                dgm_n     = round(dgm_share * sample_size, digits = 0),
                pdal_n    = round(pdal_share * sample_size, digits = 0),
                ssp_n     = round(ssp_share * sample_size, digits = 0)) -> df_polls_state
    
    # store data in list
    polls[[scenario]][["n_responses"]]   <- df_polls_state$sample_size
    polls[[scenario]][["day_poll"]]      <- sapply(df_polls_state$date, 
                                            function(x){ which(dates_campaign == x)})
    polls[[scenario]][["house_poll"]]    <- sapply(df_polls_state$pollster, 
                                            function(x){which(pollsters == x)})
    polls[[scenario]][["state_poll"]]    <- sapply(df_polls_state$geography, 
                                            function(x){which(states_regions$state == x)}) 
    polls[[scenario]][["y"]]             <- t(as.matrix(df_polls_state[, c("cc_n", "dgm_n", "pdal_n", "ssp_n")]))
    
    # regional polls ----
    dat %>%
        filter(scenario == .env$scenario,
               type_of_poll == "regional") %>%
        select(-c("scenario", "type_of_poll")) %>%
        arrange(date) -> df_polls_region  

    # convert vote shares to votes
    df_polls_region %>%
        mutate( cc_n      = round(cc_share * sample_size, digits = 0),
                dgm_n     = round(dgm_share * sample_size, digits = 0),
                pdal_n    = round(pdal_share * sample_size, digits = 0),
                ssp_n     = round(ssp_share * sample_size, digits = 0)) -> df_polls_region
    
    polls[[scenario]][["n_responses_reg"]]   <- df_polls_region$sample_size
    polls[[scenario]][["day_poll_reg"]]      <- sapply(df_polls_region$date, 
                                                function(x){ which(dates_campaign == x)})
    polls[[scenario]][["house_poll_reg"]]    <- sapply(df_polls_region$pollster, 
                                                function(x){which(pollsters == x)})
    polls[[scenario]][["region_poll"]]       <- sapply(df_polls_region$geography,
                                                function(x){which(unique(states_regions$region) == x)}) 
    polls[[scenario]][["y_reg"]]             <- t(as.matrix(df_polls_region[, c("cc_n", "dgm_n", "pdal_n", "ssp_n")]))
    
    # national polls ----
    dat %>%
        filter(scenario == .env$scenario,
               type_of_poll == "national") %>%
        select(-c("scenario", "type_of_poll")) %>%
        arrange(date) -> df_polls_national
    
    # convert vote shares to votes
    df_polls_national %>%
        mutate( cc_n      = round(cc_share * sample_size, digits = 0),
                dgm_n     = round(dgm_share * sample_size, digits = 0),
                pdal_n    = round(pdal_share * sample_size, digits = 0),
                ssp_n     = round(ssp_share * sample_size, digits = 0)) -> df_polls_national

    polls[[scenario]][["n_responses_nat"]]   <- df_polls_national$sample_size
    polls[[scenario]][["day_poll_nat"]]      <- sapply(df_polls_national$date, 
                                                function(x){ which(dates_campaign == x)})
    polls[[scenario]][["house_poll_nat"]]    <- sapply(df_polls_national$pollster, 
                                                function(x){which(pollsters == x)})
    polls[[scenario]][["y_nat"]]             <- t(as.matrix(df_polls_national[, c("cc_n", "dgm_n", "pdal_n", "ssp_n")]))
    
    # Clean up ----
    rm(df_polls_state, df_polls_region, df_polls_national)
}

# Export ----
save(polls, file = here::here("data", paste0("polls.Rda")))
rm(polls)
```

## Plot polls

```{r}
load(file = here::here("data", paste0("polls.Rda")))
```

Functions to convert polls to `data.frame` and generate plots for a given scenario

```{r}
convert_polls_to_df <- function(polls, scen) {
    df_polls <- as.data.frame(t(polls[[scen]]$y))

    df_polls$day_poll <- dates_campaign[polls[[scen]]$day_poll]
    df_polls$sample_size <- polls[[scen]]$n_responses
    df_polls$geography <- states_regions$state[polls[[scen]]$state_poll]
    df_polls$type_of_poll <- "state"

    df_polls_reg <- as.data.frame(t(polls[[scen]]$y_reg))
    df_polls_reg$day_poll <- dates_campaign[polls[[scen]]$day_poll_reg]
    df_polls_reg$sample_size <- polls[[scen]]$n_responses_reg
    df_polls_reg$geography <- unique(states_regions$region)[polls[[scen]]$region_poll]
    df_polls_reg$type_of_poll <- "regional"

    df_polls <- rbind(df_polls, df_polls_reg)

    df_polls_nat <- as.data.frame(t(polls[[scen]]$y_nat))
    df_polls_nat$day_poll <- dates_campaign[polls[[scen]]$day_poll_nat]
    df_polls_nat$sample_size <- polls[[scen]]$n_responses_nat
    df_polls_nat$geography <- "national"
    df_polls_nat$type_of_poll <- "national"

    df_polls <- rbind(df_polls, df_polls_nat)

    df_polls %>% 
        rename(CC = cc_n, 
                DGM = dgm_n, 
                PDAL = pdal_n, 
                SS = ssp_n) %>%
        tidyr::pivot_longer(cols = -c("day_poll", 
                                        "geography", 
                                        "sample_size",
                                        "type_of_poll"),
                            names_to = "party", values_to = "value") -> df_plt
    df_plt
}
```

```{r}
plot_state_polls <- function(polls, scen) {
    df_plt <- convert_polls_to_df(polls, scen)

    df_plt %>%
    filter(type_of_poll == "state") %>%
    ggplot(aes(x = day_poll, y = value/sample_size, color = party)) +
    ggsci::scale_color_jco() + 
    geom_point() +
    facet_wrap(~geography, nrow = 4) +
    labs(title = paste0(scen, ": state polls")) +
    theme(legend.position="top") -> plt_state

    plt_state
}
```

```{r}
plot_regnat_polls <- function(polls, scen) {
    df_plt <- convert_polls_to_df(polls, scen)

    df_plt %>%
        filter(type_of_poll != "state") %>%
        ggplot(aes(x = day_poll, y = value/sample_size, color = party)) +
        ggsci::scale_color_jco() + 
        geom_point() +
        facet_wrap(~geography, nrow = 2) + 
        labs(title = paste0(scen, ": regional and national polls")) + 
        theme(legend.position="top") -> plt_regnat
    plt_regnat
}
```

### Scenarios

::: {.panel-tabset}

## A

```{r}
#| echo: false
plot_state_polls(polls, scen = "A")
```

```{r}
#| echo: false
plot_regnat_polls(polls, scen = "A")
```

## B

```{r}
#| echo: false
plot_state_polls(polls, scen = "B")
```

```{r}
#| echo: false
plot_regnat_polls(polls, scen = "B")
```

## C

```{r}
#| echo: false
plot_state_polls(polls, scen = "C")
```

```{r}
#| echo: false
plot_regnat_polls(polls, scen = "C")
```

## D

```{r}
#| echo: false
plot_state_polls(polls, scen = "D")
```

```{r}
#| echo: false
plot_regnat_polls(polls, scen = "D")
```

## E

```{r}
#| echo: false
plot_state_polls(polls, scen = "E")
```

```{r}
#| echo: false
plot_regnat_polls(polls, scen = "E")
```


:::


## Compare differences between sum of votes and total number of responses

As a consequence of rounding the product of vote share and number of poll respondents to an integer, the sum of votes for the parties may not exactly match the total number of respondents in the poll. 

How large are these discrepancies? 

```{r}
df_diff <- data.frame()
for (s in scenarios){
    for (i in c("", "_reg", "_nat")){
        y <- polls[[s]][[paste0("y", i)]]
        n_responses <- polls[[s]][[paste0("n_responses", i)]] 
        diff_response <- apply(y, c(2), sum) - n_responses
        df_diff <- rbind(df_diff, data.frame(scenario = s,
                                            type = ifelse(i == "","state", substr(i, 2, nchar(i))),
                                            n_diff = sum(diff_response != 0),
                                            n_polls = length(diff_response),
                                            ratio_n_diff = sum(diff_response != 0)/length(diff_response),
                                            max_abs_diff = max(abs(diff_response)),
                                            min_N = min(n_responses),
                                            ratio_maxdiff_minN = max(abs(diff_response))/min(n_responses)
                                        )
                        )
    }
}

df_diff %>% 
    arrange(desc(ratio_maxdiff_minN))
```

